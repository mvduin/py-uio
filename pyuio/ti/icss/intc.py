########## PRU-ICSS interrupt controller #######################################
##
## Instance of the Common Platform Interrupt Controller (cpintc)
##      configurable nesting supported
##
## 64 irq inputs with configurable mapping to channels:
##       0-15  from local subsystem
##      16-31  software events generated by write to R31
##      32-63  irqs from rest of system
##
## 10 channels with configurable mapping to irq outputs
##
## 10 irq outputs:
##      0-1  to bits 30-31 of R31 of both PRU cores
##      2-9  to rest of system
##
## For each channel, lower-numbered irq inputs take priority.
## For each irq output, lower-numbered channels take priority.
##
##
## Subsystem-local irqs:
##       0  ram parity error
##       1  pru 0 serial-in 16 bits received
##       2  pru 1 serial-in 16 bits received
##       3  core-to-core xfr timeout
##       4  uart rx dma
##       5  uart tx dma
##       6  uart irq
##       7  iep overflow/capture/compare event
##       8  iep digio_event_req
##       9  iep pd watchdog expired
##      10  iep pdi watchdog expired
##      11  iep edc latch 1 input       (raw pin signal)
##      12  iep edc latch 0 input       (raw pin signal)
##      13  iep edc sync 1 out
##      14  iep edc sync 0 out
##      15  eCAP irq
##
## Note: irqs 1 and 2 will fire even if serial-in mode isn't selected.
##
## Irqs 16-31 are pulsed by writing 32-47 to R31.
##
## A subsystem config bit (cfg.intc, see icss/cfg.py) replaces irqs 32-55 with:
##      32-43   mii-rt 0 irqs
##      44-55   mii-rt 1 irqs

import ctypes
from ctypes import ( c_uint8 as ubyte, c_uint32 as uint )
from .. import irqc4

ev_t = ctypes.c_int32   # event number (0..63), negative = no event pending
ch_t = ubyte            # channel number (0..9)
out_t = ubyte           # output number (0..9)

ev_set_t = ctypes.c_uint64
out_set_t = uint

Events = irqc4.define( ev_set_t, stride=0x80 )


class _Fields( list ):
    def __init__( self ):
        self.end = 0

    def add( self, offset, c_type, name ):
        if offset > self.end:
            self.append( ("", ubyte * (offset - self.end)) )
        elif offset < self.end:
            raise Exception("offset is before end of previous field")
        self.end = offset + ctypes.sizeof( c_type )
        self.append( (name, c_type) )

class Intc( ctypes.Structure ):
    _fields_ = _Fields()

    _fields_.add( 0x000, uint, 'ident' ) #r-
    # subarctic 2.1 pruss -- 4'e82'a9'00

    _fields_.add( 0x004, uint, 'config' )
    # bit   0     z-
    # bit   1     z-
    # bits  2- 3  rw  nesting mode:
    #                   0 = disabled (no nesting)
    #                   1 = automatic, per output
    #                   2 = automatic, global
    #                   3 = manual

    _fields_.add( 0x010, uint, 'enabled' )
    # bit   0     rw  when clear, all outputs are masked

    _fields_.add( 0x01c, uint, 'nesting' )
    # bits  0- 8  r-/rw  global nesting level
    # bits  9-30  z-
    # bit  31     ->  allow write even if automatic nesting is used

    _fields_.add( 0x020, ev_t, '_ev_set_one' )
    _fields_.add( 0x024, ev_t, '_ev_clear_one' )
    _fields_.add( 0x028, ev_t, '_ev_enable_one' )
    _fields_.add( 0x02c, ev_t, '_ev_disable_one' )
    def ev_set_one( self, i ):  self._ev_set_one = i
    def ev_clear_one( self, i ):  self._ev_clear_one = i
    def ev_enable_one( self, i ):  self._ev_enable_one = i
    def ev_disable_one( self, i ):  self._ev_disable_one = i
    # these are equivalent to  self.ev.*_one( i )  but more efficient

    _fields_.add( 0x034, out_t, '_out_enable_one' )
    _fields_.add( 0x038, out_t, '_out_disable_one' )
    def out_enable_one( self, i ):  self._out_enable_one = i
    def out_disable_one( self, i ):  self._out_disable_one = i
    # these atomically set/clear single bits of self.out_enabled

    _fields_.add( 0x080, ev_t, 'event' )  #r-  global highest-priority event

    _fields_.add( 0x200, Events, 'ev' )  # events status and mask

    _fields_.add( 0x400, ch_t * 64, 'ev_ch' )    #rw  event -> channel map
    _fields_.add( 0x800, out_t * 10, 'ch_out' )  #rw  channel -> output map

    _fields_.add( 0x900, ev_t * 10, 'out_event' )  #r-  current event per output

    _fields_.add( 0xd00, ev_set_t, 'ev_polarity' )  #rw
    _fields_.add( 0xd80, ev_set_t, 'ev_edgedet' )   #rw

    _fields_.add( 0x1100, uint * 10, 'out_nesting' )
    # same format as global nesting register

    _fields_.add( 0x1500, out_set_t, 'out_enabled' )

    def initialize( self ):
        self.enabled = 0
        self.config = 0
        self.nesting = 0x100
        self.ev.disable( 0xffffffffffffffff )
        self.ev_polarity = 0xffffffffffffffff
        self.ev_edgedet = 0
        self.ev.clear( 0xffffffffffffffff )
        self.out_enabled = 0
        for i in range( 0, 10 ):
            self.ch_out[ i ] = i
            self.out_nesting[ i ] = 0x100
        self.enabled = 1
